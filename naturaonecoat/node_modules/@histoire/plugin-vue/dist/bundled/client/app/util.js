import { isRef, unref, watch as watch$1 } from "vue";
import { isRef as isRef$1, unref as unref$1, watch } from "@histoire/vendors/vue";
import { applyState } from "@histoire/shared";
const isObject = (val) => val !== null && typeof val === "object";
function toRawDeep(val, seen = /* @__PURE__ */ new WeakMap()) {
  const unwrappedValue = isRef(val) ? unref(val) : val;
  if (typeof unwrappedValue === "symbol") {
    return unwrappedValue.toString();
  }
  if (!isObject(unwrappedValue)) {
    return unwrappedValue;
  }
  if (seen.has(unwrappedValue)) {
    return seen.get(unwrappedValue);
  }
  if (Array.isArray(unwrappedValue)) {
    const result = [];
    seen.set(unwrappedValue, result);
    result.push(...unwrappedValue.map((value) => toRawDeep(value, seen)));
    return result;
  } else {
    const result = {};
    seen.set(unwrappedValue, result);
    toRawObject(unwrappedValue, result, seen);
    return result;
  }
}
const toRawObject = (obj, target, seen = /* @__PURE__ */ new WeakMap()) => {
  Object.keys(obj).forEach((key) => {
    target[key] = toRawDeep(obj[key], seen);
  });
};
function _toRawDeep(val, seen = /* @__PURE__ */ new WeakMap()) {
  const unwrappedValue = isRef$1(val) ? unref$1(val) : val;
  if (typeof unwrappedValue === "symbol") {
    return unwrappedValue.toString();
  }
  if (!isObject(unwrappedValue)) {
    return unwrappedValue;
  }
  if (seen.has(unwrappedValue)) {
    return seen.get(unwrappedValue);
  }
  if (Array.isArray(unwrappedValue)) {
    const result = [];
    seen.set(unwrappedValue, result);
    result.push(...unwrappedValue.map((value) => _toRawDeep(value, seen)));
    return result;
  } else {
    const result = {};
    seen.set(unwrappedValue, result);
    _toRawObject(unwrappedValue, result, seen);
    return result;
  }
}
const _toRawObject = (obj, target, seen = /* @__PURE__ */ new WeakMap()) => {
  Object.keys(obj).forEach((key) => {
    target[key] = toRawDeep(obj[key], seen);
  });
};
function syncStateBundledAndExternal(bundledState, externalState) {
  let syncing = false;
  const _stop = watch(() => bundledState, (value) => {
    if (value == null)
      return;
    if (!syncing) {
      syncing = true;
      applyState(externalState, _toRawDeep(value));
    } else {
      syncing = false;
    }
  }, {
    deep: true,
    immediate: true
  });
  const stop = watch$1(() => externalState, (value) => {
    if (value == null)
      return;
    if (!syncing) {
      syncing = true;
      applyState(bundledState, toRawDeep(value));
    } else {
      syncing = false;
    }
  }, {
    deep: true,
    immediate: true
  });
  return {
    stop() {
      _stop();
      stop();
    }
  };
}
export { _toRawDeep, syncStateBundledAndExternal, toRawDeep };
